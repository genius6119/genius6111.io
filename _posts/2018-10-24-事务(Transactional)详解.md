---
layout:     post
title:      事务(Transactional)详解
subtitle:   事务特性、隔离级别、传播机制
date:       2018-10-24
author:     Zwx
header-img: img/post-bg-YesOrNo.jpg
catalog: true
tags:
    - Sql
    - Java
---

---
## 前言：

　　因为是原理性的东西，所以基本都是网上抄来的。我在网上看了大量博客后，将最通俗易懂的解释整理下来，用作自己加深印象。

---
## 特性

ACID!
#### 原子性（Atomicity）

　　事务是数据库逻辑工作单元，事务中包含的操作要么都执行成功，要么都执行失败。
#### 一致性（Consistency）

　　一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。

　　一致性是指数据处于一种语义上的有意义且正确的状态（强一致性！）。一致性是对数据可见性的约束，保证在一个事务中的多次操作的数据中间状态对其他事务不可见的。

　　拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。


#### 隔离性（Isolation）

　　隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。

　　即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。

　　关于事务的隔离性数据库提供了多种隔离级别，稍后会介绍到。

#### 持久性（Durability）

　　持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。

　　例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。

#### 原子性和一致性的区别

　　原子性和一致性的的侧重点不同：原子性关注状态，要么全部成功，要么全部失败，不存在部分成功的状态。而一致性关注数据的可见性，中间状态的数据对外部不可见，只有最初状态和最终状态的数据对外可见。  

----
## 没有事务隔离性会带来的问题

#### 脏读
　　指当一个事务正字访问数据，并且对数据进行了修改，而这种数据还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据还没有提交那么另外一个事务读取到的这个数据我们称之为脏数据。依据脏数据所做的操作肯能是不正确的。
#### 不可重复读
　　不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。

　　例如事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发生了不可重复读。
#### 幻读
　　一个事务先后读取一个范围的记录，但两次读取的纪录数不同，我们称之为幻象读（两次执行同一条 select 语句会出现不同的结果，第二次读会增加一数据行，并没有说这两次执行是在同一个事务中）。
#### 细节
　　不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。

　　幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。

----
## 事务隔离级别

　　Mysql的事务隔离级别分为四种，由低到高依次分别为：Read uncommited（读未提交）、Read commited（读提交）、Repeatable read （可重复读【默认】）、Serializable（序列化），这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。

![](http://pgoj9ayje.bkt.clouddn.com/gljb.png)

----
## Spring事务传播机制
　　Spring一共定义了七种事务传播机制：

| 传播机制        | 说明           |
| ------------- |:-------------| 
| PROPAGATION_REQUIRED     | 如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是 最常见的选择，也是Spring的默认传播机制。 | 
| PROPAGATION_SUPPORTS     | 支持当前事务，如果当前没有事务，就以非事务方式执行。      |
| PROPAGATION_MANDATORY | 使用当前的事务，如果当前没有事务，就抛出异常。    |
| PROPAGATION_REQUIRES_NEW | 新建事务，如果当前存在事务，把当前事务挂起。     |
| PROPAGATION_NOT_SUPPORTED | 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。     |
| PROPAGATION_NEVER | 以非事务方式执行，如果当前存在事务，则抛出异常。     |
| PROPAGATION_NESTED | 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与 PROPAGATION_REQUIRED 类似的操作。      |

----
## Spring事务管理方式

#### 编程式事务
　　自己写代码定义事务逻辑，侵入了主体逻辑，最细粒度为代码语句。
#### 声明式事务
　　可以用@Transactional注解，最细粒度为方法。
  
　　这部分内容下一篇再写~
　　
